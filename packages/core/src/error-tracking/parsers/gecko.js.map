{"version":3,"file":"gecko.js","sourceRoot":"","sources":["gecko.ts"],"names":[],"mappings":";AAAA,8HAA8H;AAC9H,qGAAqG;;;;;;;;;;;;;;;;;;;AAGrG,+BAAsD;AACtD,mCAAwD;AAExD,8EAA8E;AAC9E,IAAM,UAAU,GACd,sIAAsI,CAAA;AACxI,IAAM,cAAc,GAAG,+CAA+C,CAAA;AAE/D,IAAM,oBAAoB,GAAoB,UAAC,IAAI;;IACxD,IAAM,KAAK,GAAG,UAAU,CAAC,IAAI,CAAC,IAAI,CAA4D,CAAA;IAE9F,IAAI,KAAK,EAAE,CAAC;QACV,IAAM,MAAM,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAA;QAC3D,IAAI,MAAM,EAAE,CAAC;YACX,IAAM,QAAQ,GAAG,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAoC,CAAA;YAEjF,IAAI,QAAQ,EAAE,CAAC;gBACb,0DAA0D;gBAC1D,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,MAAM,CAAA;gBAC7B,KAAK,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAA;gBACtB,KAAK,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAA;gBACtB,KAAK,CAAC,CAAC,CAAC,GAAG,EAAE,CAAA,CAAC,sBAAsB;YACtC,CAAC;QACH,CAAC;QAED,IAAI,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC,CAAA;QACvB,IAAI,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,uBAAgB,CACtC;QAAA,KAAA,OAAmB,IAAA,sCAA6B,EAAC,IAAI,EAAE,QAAQ,CAAC,IAAA,EAA/D,IAAI,QAAA,EAAE,QAAQ,QAAA,CAAiD;QAEjE,OAAO,IAAA,kBAAW,EAAC,QAAQ,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAA;IACxG,CAAC;IAED,OAAM;AACR,CAAC,CAAA;AAzBY,QAAA,oBAAoB,wBAyBhC","sourcesContent":["// gecko regex: `(?:bundle|\\d+\\.js)`: `bundle` is for react native, `\\d+\\.js` also but specifically for ram bundles because it\n// generates filenames without a prefix like `file://` the filenames in the stacktrace are just 42.js\n\nimport { StackLineParser } from '../types'\nimport { createFrame, UNKNOWN_FUNCTION } from './base'\nimport { extractSafariExtensionDetails } from './safari'\n\n// We need this specific case for now because we want no other regex to match.\nconst geckoREgex =\n  /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)?((?:[-a-z]+)?:\\/.*?|\\[native code\\]|[^@]*(?:bundle|\\d+\\.js)|\\/[\\w\\-. /=]+)(?::(\\d+))?(?::(\\d+))?\\s*$/i\nconst geckoEvalRegex = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i\n\nexport const geckoStackLineParser: StackLineParser = (line) => {\n  const parts = geckoREgex.exec(line) as null | [string, string, string, string, string, string]\n\n  if (parts) {\n    const isEval = parts[3] && parts[3].indexOf(' > eval') > -1\n    if (isEval) {\n      const subMatch = geckoEvalRegex.exec(parts[3]) as null | [string, string, string]\n\n      if (subMatch) {\n        // throw out eval line/column and use top-most line number\n        parts[1] = parts[1] || 'eval'\n        parts[3] = subMatch[1]\n        parts[4] = subMatch[2]\n        parts[5] = '' // no column when eval\n      }\n    }\n\n    let filename = parts[3]\n    let func = parts[1] || UNKNOWN_FUNCTION\n    ;[func, filename] = extractSafariExtensionDetails(func, filename)\n\n    return createFrame(filename, func, parts[4] ? +parts[4] : undefined, parts[5] ? +parts[5] : undefined)\n  }\n\n  return\n}\n"]}