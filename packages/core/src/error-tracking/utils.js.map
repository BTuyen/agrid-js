{"version":3,"file":"utils.js","sourceRoot":"","sources":["utils.ts"],"names":[],"mappings":";AAAA,kGAAkG;AAClG,iCAAiC;;;AAEjC,uCAAuC;AACvC;IAGE,yBAAoC,QAAgB;QAAhB,aAAQ,GAAR,QAAQ,CAAQ;QAClD,IAAI,CAAC,MAAM,GAAG,IAAI,GAAG,EAAQ,CAAA;IAC/B,CAAC;IAED,yGAAyG;IAClG,6BAAG,GAAV,UAAW,GAAM;QACf,IAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;QAClC,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;YACxB,OAAO,SAAS,CAAA;QAClB,CAAC;QACD,2CAA2C;QAC3C,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;QACvB,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;QAC3B,OAAO,KAAK,CAAA;IACd,CAAC;IAED,wEAAwE;IACjE,6BAAG,GAAV,UAAW,GAAM,EAAE,KAAQ;QACzB,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;IAC7B,CAAC;IAED,kEAAkE;IAC3D,gCAAM,GAAb;QACE,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YACzC,IAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,KAAK,CAAA;YAC7C,IAAI,KAAK,EAAE,CAAC;gBACV,yFAAyF;gBACzF,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAA;YAC3B,CAAC;QACH,CAAC;IACH,CAAC;IACH,sBAAC;AAAD,CAAC,AAlCD,IAkCC;AAlCY,0CAAe","sourcesContent":["// Portions of this file are derived from getsentry/sentry-javascript by Software, Inc. dba Sentry\n// Licensed under the MIT License\n\n/** A simple Least Recently Used map */\nexport class ReduceableCache<K, V> {\n  private readonly _cache: Map<K, V>\n\n  public constructor(private readonly _maxSize: number) {\n    this._cache = new Map<K, V>()\n  }\n\n  /** Get an entry or undefined if it was not in the cache. Re-inserts to update the recently used order */\n  public get(key: K): V | undefined {\n    const value = this._cache.get(key)\n    if (value === undefined) {\n      return undefined\n    }\n    // Remove and re-insert to update the order\n    this._cache.delete(key)\n    this._cache.set(key, value)\n    return value\n  }\n\n  /** Insert an entry and evict an older entry if we've reached maxSize */\n  public set(key: K, value: V): void {\n    this._cache.set(key, value)\n  }\n\n  /** Remove an entry and return the entry if it was in the cache */\n  public reduce(): void {\n    while (this._cache.size >= this._maxSize) {\n      const value = this._cache.keys().next().value\n      if (value) {\n        // keys() returns an iterator in insertion order so keys().next() gives us the oldest key\n        this._cache.delete(value)\n      }\n    }\n  }\n}\n"]}