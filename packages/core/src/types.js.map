{"version":3,"file":"types.js","sourceRoot":"","sources":["types.ts"],"names":[],"mappings":"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","sourcesContent":["export type PostHogCoreOptions = {\n  /** PostHog API host, usually 'https://us.i.posthog.com' or 'https://eu.i.posthog.com' */\n  host?: string\n  /** The number of events to queue before sending to PostHog (flushing) */\n  flushAt?: number\n  /** The interval in milliseconds between periodic flushes */\n  flushInterval?: number\n  /** The maximum number of queued messages to be flushed as part of a single batch (must be higher than `flushAt`) */\n  maxBatchSize?: number\n  /** The maximum number of cached messages either in memory or on the local storage.\n   * Defaults to 1000, (must be higher than `flushAt`)\n   */\n  maxQueueSize?: number\n  /** If set to true the SDK is essentially disabled (useful for local environments where you don't want to track anything) */\n  disabled?: boolean\n  /** If set to false the SDK will not track until the `optIn` function is called. */\n  defaultOptIn?: boolean\n  /** Whether to track that `getFeatureFlag` was called (used by Experiments) */\n  sendFeatureFlagEvent?: boolean\n  /** Whether to load feature flags when initialized or not */\n  preloadFeatureFlags?: boolean\n  /**\n   * Whether to load remote config when initialized or not\n   * Experimental support\n   * Default: false - Remote config is loaded by default\n   */\n  disableRemoteConfig?: boolean\n  /**\n   * Whether to load surveys when initialized or not\n   * Experimental support\n   * Default: false - Surveys are loaded by default, but requires the `PostHogSurveyProvider` to be used\n   */\n  disableSurveys?: boolean\n  /** Option to bootstrap the library with given distinctId and feature flags */\n  bootstrap?: {\n    distinctId?: string\n    isIdentifiedId?: boolean\n    featureFlags?: Record<string, FeatureFlagValue>\n    featureFlagPayloads?: Record<string, JsonType>\n  }\n  /** How many times we will retry HTTP requests. Defaults to 3. */\n  fetchRetryCount?: number\n  /** The delay between HTTP request retries, Defaults to 3 seconds. */\n  fetchRetryDelay?: number\n  /** Timeout in milliseconds for any calls. Defaults to 10 seconds. */\n  requestTimeout?: number\n  /** Timeout in milliseconds for feature flag calls. Defaults to 10 seconds for stateful clients, and 3 seconds for stateless. */\n  featureFlagsRequestTimeoutMs?: number\n  /** Timeout in milliseconds for remote config calls. Defaults to 3 seconds. */\n  remoteConfigRequestTimeoutMs?: number\n  /** For Session Analysis how long before we expire a session (defaults to 30 mins) */\n  sessionExpirationTimeSeconds?: number\n  /** Whether to disable GZIP compression */\n  disableCompression?: boolean\n  disableGeoip?: boolean\n  /** Special flag to indicate ingested data is for a historical migration. */\n  historicalMigration?: boolean\n  /**\n   * Evaluation environments for feature flags.\n   * When set, only feature flags that have at least one matching evaluation tag\n   * will be evaluated for this SDK instance. Feature flags with no evaluation tags\n   * will always be evaluated.\n   *\n   * Examples: ['production', 'web', 'mobile']\n   *\n   * @default undefined\n   */\n  evaluationEnvironments?: readonly string[]\n}\n\nexport enum PostHogPersistedProperty {\n  AnonymousId = 'anonymous_id',\n  DistinctId = 'distinct_id',\n  Props = 'props',\n  FeatureFlagDetails = 'feature_flag_details',\n  FeatureFlags = 'feature_flags',\n  FeatureFlagPayloads = 'feature_flag_payloads',\n  BootstrapFeatureFlagDetails = 'bootstrap_feature_flag_details',\n  BootstrapFeatureFlags = 'bootstrap_feature_flags',\n  BootstrapFeatureFlagPayloads = 'bootstrap_feature_flag_payloads',\n  OverrideFeatureFlags = 'override_feature_flags',\n  Queue = 'queue',\n  OptedOut = 'opted_out',\n  SessionId = 'session_id',\n  SessionStartTimestamp = 'session_start_timestamp',\n  SessionLastTimestamp = 'session_timestamp',\n  PersonProperties = 'person_properties',\n  GroupProperties = 'group_properties',\n  InstalledAppBuild = 'installed_app_build', // only used by posthog-react-native\n  InstalledAppVersion = 'installed_app_version', // only used by posthog-react-native\n  SessionReplay = 'session_replay', // only used by posthog-react-native\n  SurveyLastSeenDate = 'survey_last_seen_date', // only used by posthog-react-native\n  SurveysSeen = 'surveys_seen', // only used by posthog-react-native\n  Surveys = 'surveys', // only used by posthog-react-native\n  RemoteConfig = 'remote_config',\n  FlagsEndpointWasHit = 'flags_endpoint_was_hit', // only used by posthog-react-native\n}\n\nexport type PostHogFetchOptions = {\n  method: 'GET' | 'POST' | 'PUT' | 'PATCH'\n  mode?: 'no-cors'\n  credentials?: 'omit'\n  headers: { [key: string]: string }\n  body?: string | Blob\n  signal?: AbortSignal\n}\n\n// Check out posthog-js for these additional options and try to keep them in sync\nexport type PostHogCaptureOptions = {\n  /** If provided overrides the auto-generated event ID */\n  uuid?: string\n  /** If provided overrides the auto-generated timestamp */\n  timestamp?: Date\n  disableGeoip?: boolean\n}\n\nexport type PostHogFetchResponse = {\n  status: number\n  text: () => Promise<string>\n  json: () => Promise<any>\n}\n\nexport type PostHogQueueItem = {\n  message: any\n  callback?: (err: any) => void\n}\n\nexport type PostHogEventProperties = {\n  [key: string]: JsonType\n}\n\nexport type PostHogGroupProperties = {\n  [type: string]: string | number\n}\n\nexport type PostHogAutocaptureElement = {\n  $el_text?: string\n  tag_name: string\n  href?: string\n  nth_child?: number\n  nth_of_type?: number\n  order?: number\n} & PostHogEventProperties\n// Any key prefixed with `attr__` can be added\n\nexport enum Compression {\n  GZipJS = 'gzip-js',\n  Base64 = 'base64',\n}\n\nexport type PostHogRemoteConfig = {\n  sessionRecording?:\n    | boolean\n    | {\n        [key: string]: JsonType\n      }\n\n  /**\n   * Supported compression algorithms\n   */\n  supportedCompression?: Compression[]\n\n  /**\n   * Whether surveys are enabled\n   */\n  surveys?: boolean | Survey[]\n\n  /**\n   * Indicates if the team has any flags enabled (if not we don't need to load them)\n   */\n  hasFeatureFlags?: boolean\n}\n\nexport type FeatureFlagValue = string | boolean\n\nexport type PostHogFlagsResponse = Omit<PostHogRemoteConfig, 'hasFeatureFlags'> & {\n  featureFlags: {\n    [key: string]: FeatureFlagValue\n  }\n  featureFlagPayloads: {\n    [key: string]: JsonType\n  }\n  flags: {\n    [key: string]: FeatureFlagDetail\n  }\n  errorsWhileComputingFlags: boolean\n  sessionRecording?:\n    | boolean\n    | {\n        [key: string]: JsonType\n      }\n  quotaLimited?: string[]\n  requestId?: string\n}\n\nexport type PostHogFeatureFlagsResponse = PartialWithRequired<\n  PostHogFlagsResponse,\n  'flags' | 'featureFlags' | 'featureFlagPayloads' | 'requestId'\n>\n\n/**\n * Creates a type with all properties of T, but makes only K properties required while the rest remain optional.\n *\n * @template T - The base type containing all properties\n * @template K - Union type of keys from T that should be required\n *\n * @example\n * interface User {\n *   id: number;\n *   name: string;\n *   email?: string;\n *   age?: number;\n * }\n *\n * // Makes 'id' and 'name' required, but 'email' and 'age' optional\n * type RequiredUser = PartialWithRequired<User, 'id' | 'name'>;\n *\n * const user: RequiredUser = {\n *   id: 1,      // Must be provided\n *   name: \"John\" // Must be provided\n *   // email and age are optional\n * };\n */\nexport type PartialWithRequired<T, K extends keyof T> = {\n  [P in K]: T[P] // Required fields\n} & {\n  [P in Exclude<keyof T, K>]?: T[P] // Optional fields\n}\n\n/**\n * These are the fields we care about from PostHogFlagsResponse for feature flags.\n */\nexport type PostHogFeatureFlagDetails = PartialWithRequired<\n  PostHogFlagsResponse,\n  'flags' | 'featureFlags' | 'featureFlagPayloads' | 'requestId'\n>\n\n/**\n * Models the response from the v1 `/flags` endpoint.\n */\nexport type PostHogV1FlagsResponse = Omit<PostHogFlagsResponse, 'flags'>\n\n/**\n * Models the response from the v2 `/flags` endpoint.\n */\nexport type PostHogV2FlagsResponse = Omit<PostHogFlagsResponse, 'featureFlags' | 'featureFlagPayloads'>\n\n/**\n * The format of the flags object in persisted storage\n *\n * When we pull flags from persistence, we can normalize them to PostHogFeatureFlagDetails\n * so that we can support v1 and v2 of the API.\n */\nexport type PostHogFlagsStorageFormat = Pick<PostHogFeatureFlagDetails, 'flags'>\n\n/**\n * Models legacy flags and payloads return type for many public methods.\n */\nexport type PostHogFlagsAndPayloadsResponse = Partial<\n  Pick<PostHogFlagsResponse, 'featureFlags' | 'featureFlagPayloads'>\n>\n\nexport type JsonType = string | number | boolean | null | { [key: string]: JsonType } | Array<JsonType> | JsonType[]\n\nexport type FetchLike = (url: string, options: PostHogFetchOptions) => Promise<PostHogFetchResponse>\n\nexport type FeatureFlagDetail = {\n  key: string\n  enabled: boolean\n  variant: string | undefined\n  reason: EvaluationReason | undefined\n  metadata: FeatureFlagMetadata | undefined\n}\n\nexport type FeatureFlagMetadata = {\n  id: number | undefined\n  version: number | undefined\n  description: string | undefined\n  // Payloads in the response are always JSON encoded as a string\n  payload: string | undefined\n}\n\nexport type EvaluationReason = {\n  code: string | undefined\n  condition_index: number | undefined\n  description: string | undefined\n}\n\n// survey types\nexport type SurveyAppearance = {\n  // keep in sync with frontend/src/types.ts -> SurveyAppearance\n  backgroundColor?: string\n  submitButtonColor?: string\n  // deprecate submit button text eventually\n  submitButtonText?: string\n  submitButtonTextColor?: string\n  ratingButtonColor?: string\n  ratingButtonActiveColor?: string\n  autoDisappear?: boolean\n  displayThankYouMessage?: boolean\n  thankYouMessageHeader?: string\n  thankYouMessageDescription?: string\n  thankYouMessageDescriptionContentType?: SurveyQuestionDescriptionContentType\n  thankYouMessageCloseButtonText?: string\n  borderColor?: string\n  position?: SurveyPosition\n  placeholder?: string\n  shuffleQuestions?: boolean\n  surveyPopupDelaySeconds?: number\n  // widget options\n  widgetType?: SurveyWidgetType\n  widgetSelector?: string\n  widgetLabel?: string\n  widgetColor?: string\n}\n\nexport enum SurveyPosition {\n  TopLeft = 'top_left',\n  TopCenter = 'top_center',\n  TopRight = 'top_right',\n  MiddleLeft = 'middle_left',\n  MiddleCenter = 'middle_center',\n  MiddleRight = 'middle_right',\n  Left = 'left',\n  Right = 'right',\n  Center = 'center',\n}\n\nexport enum SurveyWidgetType {\n  Button = 'button',\n  Tab = 'tab',\n  Selector = 'selector',\n}\n\nexport enum SurveyType {\n  Popover = 'popover',\n  API = 'api',\n  Widget = 'widget',\n  ExternalSurvey = 'external_survey',\n}\n\nexport type SurveyQuestion = BasicSurveyQuestion | LinkSurveyQuestion | RatingSurveyQuestion | MultipleSurveyQuestion\n\nexport enum SurveyQuestionDescriptionContentType {\n  Html = 'html',\n  Text = 'text',\n}\n\ntype SurveyQuestionBase = {\n  question: string\n  id: string\n  description?: string\n  descriptionContentType?: SurveyQuestionDescriptionContentType\n  optional?: boolean\n  buttonText?: string\n  originalQuestionIndex: number\n  branching?: NextQuestionBranching | EndBranching | ResponseBasedBranching | SpecificQuestionBranching\n}\n\nexport type BasicSurveyQuestion = SurveyQuestionBase & {\n  type: SurveyQuestionType.Open\n}\n\nexport type LinkSurveyQuestion = SurveyQuestionBase & {\n  type: SurveyQuestionType.Link\n  link?: string\n}\n\nexport type RatingSurveyQuestion = SurveyQuestionBase & {\n  type: SurveyQuestionType.Rating\n  display: SurveyRatingDisplay\n  scale: 3 | 5 | 7 | 10\n  lowerBoundLabel: string\n  upperBoundLabel: string\n}\n\nexport enum SurveyRatingDisplay {\n  Number = 'number',\n  Emoji = 'emoji',\n}\n\nexport type MultipleSurveyQuestion = SurveyQuestionBase & {\n  type: SurveyQuestionType.SingleChoice | SurveyQuestionType.MultipleChoice\n  choices: string[]\n  hasOpenChoice?: boolean\n  shuffleOptions?: boolean\n}\n\nexport enum SurveyQuestionType {\n  Open = 'open',\n  MultipleChoice = 'multiple_choice',\n  SingleChoice = 'single_choice',\n  Rating = 'rating',\n  Link = 'link',\n}\n\nexport enum SurveyQuestionBranchingType {\n  NextQuestion = 'next_question',\n  End = 'end',\n  ResponseBased = 'response_based',\n  SpecificQuestion = 'specific_question',\n}\n\nexport type NextQuestionBranching = {\n  type: SurveyQuestionBranchingType.NextQuestion\n}\n\nexport type EndBranching = {\n  type: SurveyQuestionBranchingType.End\n}\n\nexport type ResponseBasedBranching = {\n  type: SurveyQuestionBranchingType.ResponseBased\n  responseValues: Record<string, any>\n}\n\nexport type SpecificQuestionBranching = {\n  type: SurveyQuestionBranchingType.SpecificQuestion\n  index: number\n}\n\nexport type SurveyResponse = {\n  surveys: Survey[]\n}\n\nexport type SurveyCallback = (surveys: Survey[]) => void\n\nexport enum SurveyMatchType {\n  Regex = 'regex',\n  NotRegex = 'not_regex',\n  Exact = 'exact',\n  IsNot = 'is_not',\n  Icontains = 'icontains',\n  NotIcontains = 'not_icontains',\n}\n\nexport type SurveyElement = {\n  text?: string\n  $el_text?: string\n  tag_name?: string\n  href?: string\n  attr_id?: string\n  attr_class?: string[]\n  nth_child?: number\n  nth_of_type?: number\n  attributes?: Record<string, any>\n  event_id?: number\n  order?: number\n  group_id?: number\n}\nexport type SurveyRenderReason = {\n  visible: boolean\n  disabledReason?: string\n}\n\nexport type Survey = {\n  // Sync this with the backend's SurveyAPISerializer!\n  id: string\n  name: string\n  description?: string\n  type: SurveyType\n  feature_flag_keys?: {\n    key: string\n    value?: string\n  }[]\n  linked_flag_key?: string\n  targeting_flag_key?: string\n  internal_targeting_flag_key?: string\n  questions: SurveyQuestion[]\n  appearance?: SurveyAppearance\n  conditions?: {\n    url?: string\n    selector?: string\n    seenSurveyWaitPeriodInDays?: number\n    urlMatchType?: SurveyMatchType\n    events?: {\n      repeatedActivation?: boolean\n      values?: {\n        name: string\n      }[]\n    }\n    actions?: {\n      values: SurveyActionType[]\n    }\n    deviceTypes?: string[]\n    deviceTypesMatchType?: SurveyMatchType\n    linkedFlagVariant?: string\n  }\n  start_date?: string\n  end_date?: string\n  current_iteration?: number\n  current_iteration_start_date?: string\n}\n\nexport type SurveyActionType = {\n  id: number\n  name?: string\n  steps?: ActionStepType[]\n}\n\n/** Sync with plugin-server/src/types.ts */\nexport enum ActionStepStringMatching {\n  Contains = 'contains',\n  Exact = 'exact',\n  Regex = 'regex',\n}\n\nexport type ActionStepType = {\n  event?: string\n  selector?: string\n  text?: string\n  /** @default StringMatching.Exact */\n  text_matching?: ActionStepStringMatching\n  href?: string\n  /** @default ActionStepStringMatching.Exact */\n  href_matching?: ActionStepStringMatching\n  url?: string\n  /** @default StringMatching.Contains */\n  url_matching?: ActionStepStringMatching\n}\n\nexport type Logger = {\n  info: (...args: any[]) => void\n  warn: (...args: any[]) => void\n  error: (...args: any[]) => void\n  critical: (...args: any[]) => void\n  createLogger: (prefix: string) => Logger\n}\n\nexport const knownUnsafeEditableEvent = [\n  '$snapshot',\n  '$pageview',\n  '$pageleave',\n  '$set',\n  'survey dismissed',\n  'survey sent',\n  'survey shown',\n  '$identify',\n  '$groupidentify',\n  '$create_alias',\n  '$$client_ingestion_warning',\n  '$web_experiment_applied',\n  '$feature_enrollment_update',\n  '$feature_flag_called',\n] as const\n\n/**\n * These events can be processed by the `beforeCapture` function\n * but can cause unexpected confusion in data.\n *\n * Some features of PostHog rely on receiving 100% of these events\n */\nexport type KnownUnsafeEditableEvent = (typeof knownUnsafeEditableEvent)[number]\n"]}